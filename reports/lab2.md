# Lab2 实验报告

## 功能实现

本 Lab 实现了对 `sys_get_time` 和 `sys_task_info` 两个 system call 的重写，使其适配使用 SV39 多级页表机制实现的虚拟内存系统，通过对本应用内存空间的虚拟地址进行转换，获得对应的物理地址，由 OS 在物理地址中写入数据，即可正常传递数据。 

本 Lab 也实现了 `mmap` 和 `munmap` 匿名映射机制，通过在 Memory Set 中创建/移除 Frame Area（并更新 Page Table），实现了相关功能。

## 简答作业

### 第 1 题

SV39 页表项共 64 位，其中 [0:7] 为标志位，[10:53] 为（三级）物理页号，其余位置均为未使用。标志位可用于标识一个页表项所对应的页面的属性，由低位到高位依次是 V（页表项是否可用）、R（页面是否可读）、W（页面是否可写）、X（页面是否可执行代码）、U（用户空间是否可见）G（是否阻止页表项缓存至 TLE）、A（页面是否被访问过）、D（页面是否被修改过）。

### 第 2 题

1. `StoreFault`, `StorePageFault`, `LoadFault`, `LoadPageFault` 均有可能是缺页导致的。除了 lab1 描述过的 `sstatus`, `sepc` 和 `sscratch` 寄存器，还有 `stval`, `scause`, `satp` 寄存器会被使用，它们分别用于存储引发缺页异常的指令地址、具体的异常原因、引发缺页的页表地址。

2. 这样做有利于尽量缩小应用程序使用的主存空间，仅当应用程序需要使用某部分代码时，才从磁盘读取到主存中。

3. 大约占用 20-30 MB 内存。要想实现 Lazy 策略，只需在缺页中断时将数据从磁盘载入到主存，并映射到虚拟页面上，结束中断，重新执行指令即可。

4. 当页面失效时，页表项的 V 标志位会被设置为 0，代表页面失效。

### 第 3 题

1. 只需要在切换应用时更换页表即可。

2. 只需设置页表项的 U 标志位为 0 即可。

3. 占用的主存更小，不需要频繁清空 TLB，换页也比较方便。

4. 双页表实现下，需要在内核态/用户态切换，或应用切换时更换页表。对于一个单页表操作系统，应当在切换应用时更换页表。

## 荣誉准则

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：

    无

2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：

    无

3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。

4. 我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计。